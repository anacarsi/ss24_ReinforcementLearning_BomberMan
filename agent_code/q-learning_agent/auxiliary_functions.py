import numpy as np
import networkx as nx

def set_objetive(self, game_state: dict):
    """
    DETERMINISTIC. DISCARDED.
    Sets the objective for the agent based on the game state.
    Parameters:
    - game_state (dict): The current game state containing the field and coin information.
    Returns:
    - objective: The objective for the agent, which can be a crate or a coin.
    """
    field = game_state['field'].copy()
    coin_array=game_state['coins'].copy()
    player_pos = game_state['self'][3]

    if not coin_array:
        crates = np.argwhere(field == 1)
        if not np.any(crates):
            #no crates in the field. Set new objetcive to the nearest opponent.
            opponents = game_state['others']
            if opponents:
                objective = opponents[0][3]
            else:
                #no objective. Go to the center of the field to have highest vision.
                objective = (0,0)
        else:
            #no coins in the field. Set new objetcive to the nearest crate.
            objective = crates[0]
    else:
        #there are coins. Set new objetcive to the nearest coin.
        objective = coin_array[0]
    
    return tuple(objective)


def bomb_map(self, game_state: dict)->np.ndarray:
    
    """
    Generates a bomb map based on the given game state, and that behind a wall the agent is protected from the bomb.
    Parameters:
    - game_state (dict): The current game state containing the field and bomb information.
    Returns:
    - bomb_map: A 2D array representing the bomb map, where each element represents the timer value of a bomb.
    The bomb map is generated by iterating over the bombs in the game state and updating the timer values of the affected tiles.
    The size of the bomb map is adjusted to match the size of the field in the game state.
    The initial timer value for each tile is set to 5, and explodes when it reaches 1.
    The timer value of a tile is updated if a bomb with a shorter timer is found.
    The bomb map is returned as a 2D array.
    """
    field = game_state['field']

    #adjust size of the bomb map to the field size
    bomb_map = np.full((self.rows,self.cols), -1)
    bombs = game_state['bombs']
    
    for bomb in bombs:
        bomb_center_x, bomb_center_y = bomb[0][0], bomb[0][1]
        bomb_timer = bomb[1] + 1
        
        #affected tiles classic scenario
        #affected_tiles_up = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
        #affected_tiles_down = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
        #affected_tiles_left = [(bomb_center_x-1, bomb_center_y), (bomb_center_x-2, bomb_center_y), (bomb_center_x-3, bomb_center_y)]
        #affected_tiles_right = [(bomb_center_x+1, bomb_center_y), (bomb_center_x+2, bomb_center_y), (bomb_center_x+3, bomb_center_y)]
        
        #affected tiles 1-goal scenario
        #We consider in affected_tiles_up the bomb center and in the rest not.
        affected_tiles_up = [(bomb_center_x, bomb_center_y),(bomb_center_x, bomb_center_y-1)]
        affected_tiles_down = [(bomb_center_x, bomb_center_y+1)]
        affected_tiles_left = [(bomb_center_x-1, bomb_center_y)]
        affected_tiles_right = [(bomb_center_x+1, bomb_center_y)]

        for tile in affected_tiles_up:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile] 
            bomb_map[tile] = bomb_timer 
            # bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_down:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_left:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_right:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

    explosion_map = game_state['explosion_map']

    bomb_map[explosion_map == 1] = 1
    return bomb_map


def build_field(self, game_state: dict):
    """
    Builds the game field based on the given game state.
    Parameters:
    - self: The instance of the class.
    - game_state (dict): The dictionary containing the game state.
    Returns:
    - field (numpy.ndarray): The built game field.
    The function builds the game field by adjusting the scale of crates to 1, coins to 3, 
    bombs to 2, and free spaces to 0.
    The function returns the built game field.
    """
    field = game_state['field']
    
    for (coords, value) in game_state['bombs']:
        field[coords] = 2  

    coin_map = game_state['coins']
    for coin in coin_map:
        field[coin] = 3

    oppponents = game_state['others']
    for opp in oppponents:
        field[opp[3]] = 4
    
    return field


def agent_vision(self, field: np.ndarray, player_pos: tuple, radius: int = 3):
    """
    Generates the agent's vision based on the field and player position.
    Parameters:
    - self: The instance of the class.
    - field (numpy.ndarray): The game field.
    - player_pos (tuple): The player position.
    - radius (int): The vision radius around the player (default is 3).
    
    Returns:
    - vision (numpy.ndarray): The agent's vision.
    
    The function generates the agent's vision by creating a (2*radius+1)x(2*radius+1) grid centered 
    around the player position. If the player is near the boundary, vision is clipped accordingly.
    """
    vision = np.zeros((2*radius+1, 2*radius+1))    

    left = player_pos[0] - radius
    right = player_pos[0] + radius  
    up = player_pos[1] - radius
    down = player_pos[1] + radius 
    for i in range(2*radius+1):
        for j in range(2*radius+1):
            if (left + i)< 0 or (left + i) >= field.shape[0]-1 or up+j < 0 or up+j >= field.shape[1]-1:
                vision[i,j ] = -1
                
            else:
                vision[i, j ] = field[left+i,up+j]

    return vision


#dicarded, leaded to deterministic behaviour
def dijkstra(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 0 # Wall (not passable)
    grid[field == -2] = 1  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 1
    grid[field == 1] = 1
    grid[field == 2] = 1
    grid[field == 3] = 1
    grid[field == 4] = 1
    grid[field == -3] = 1
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 0)
    for wall in walls:
        graph.remove_node(tuple(wall))
    # Find the start node
    start = tuple(player_pos)
    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
