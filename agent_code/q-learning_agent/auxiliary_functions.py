import numpy as np
import networkx as nx

def set_objetive(self, game_state: dict):
    """
    TO BE MADE BETTER SO THAT IT CHOOSES THE NEAREST OBJECTIVE.
    S
    Sets the objective for the agent based on the game state.
    Parameters:
    - game_state (dict): The current game state containing the field and coin information.
    Returns:
    - objective: The objective for the agent, which can be a crate or a coin.
    """
    # probably "copy" can be deleted, but still not sure if it is passed by reference or by value.
    field = game_state['field'].copy()
    coin_array=game_state['coins'].copy()
    player_pos = game_state['self'][3]

    if not coin_array:
        crates = np.argwhere(field == -2)
        if not np.any(crates):
            objective = player_pos
        else:
            objective = crates[0]
        #to be refined in this way in the future. Now we will always have a crate or a coin.

        #no coins in the field. Set new objetcive to the nearest crate.
        #crates = np.argwhere(field == 1)
        #if not crates:
            #no crates in the field. Set new objetcive to the nearest opponent.

            #NEW OBJETCTIVE NOT REALLY SET. IT SHOULD BE TO KILL NEAREST OPPONENT!
        #    other_agents = game_state['others']
        #else:
        #    nearest_crate = crates[0]
    else:
        objective = coin_array[0]
    
    return tuple(objective)


def bomb_map(self, game_state: dict)->np.ndarray:
    
    """
    Generates a bomb map based on the given game state, and that behind a wall the agent is protected from the bomb.
    Parameters:
    - game_state (dict): The current game state containing the field and bomb information.
    Returns:
    - bomb_map: A 2D array representing the bomb map, where each element represents the timer value of a bomb.
    The bomb map is generated by iterating over the bombs in the game state and updating the timer values of the affected tiles.
    The size of the bomb map is adjusted to match the size of the field in the game state.
    The initial timer value for each tile is set to 5, and explodes when it reaches 1.
    The timer value of a tile is updated if a bomb with a shorter timer is found.
    The bomb map is returned as a 2D array.
    """
    field = game_state['field'].copy()

    #adjust size of the bomb map to the field size
    bomb_map = np.full((self.rows,self.cols), -1)
    bombs = game_state['bombs'].copy()
    
    for bomb in bombs:
        bomb_center_x, bomb_center_y = bomb[0][0], bomb[0][1]
        bomb_timer = bomb[1] + 1
        
        #affected tiles classic scenario
        #affected_tiles_up = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
        #affected_tiles_down = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
        #affected_tiles_left = [(bomb_center_x-1, bomb_center_y), (bomb_center_x-2, bomb_center_y), (bomb_center_x-3, bomb_center_y)]
        #affected_tiles_right = [(bomb_center_x+1, bomb_center_y), (bomb_center_x+2, bomb_center_y), (bomb_center_x+3, bomb_center_y)]
        
        #affected tiles 1-goal scenario
        #We consider in affected_tiles_up the bomb center and in the rest not.
        affected_tiles_up = [(bomb_center_x, bomb_center_y),(bomb_center_x, bomb_center_y-1)]
        affected_tiles_down = [(bomb_center_x, bomb_center_y+1)]
        affected_tiles_left = [(bomb_center_x-1, bomb_center_y)]
        affected_tiles_right = [(bomb_center_x+1, bomb_center_y)]

        for tile in affected_tiles_up:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile] 
            bomb_map[tile] = bomb_timer 
            # bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_down:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_left:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

        for tile in affected_tiles_right:
            if field[tile] == -1:
                break
            timer_tile = bomb_map[tile]
            bomb_map[tile] = bomb_timer #if (timer_tile > bomb_timer) else timer_tile

    explosion_map = game_state['explosion_map'].copy()

    bomb_map[explosion_map == 1] = 1
    return bomb_map


def build_field(self, game_state: dict):
    """
    Builds the game field based on the given game state.
    Parameters:
    - self: The instance of the class.
    - game_state (dict): The dictionary containing the game state.
    Returns:
    - field (numpy.ndarray): The built game field.
    The function builds the game field by adjusting the scale of crates to 1, coins to 3, 
    bombs to 2, and free spaces to 0.
    The function returns the built game field.
    """
    field = game_state['field'].copy()
    
    for (coords, value) in game_state['bombs'].copy():
        field[coords] = 2  

    coin_map = game_state['coins'].copy()
    for coin in coin_map:
        field[coin] = 3
    return field


def agent_vision(self, field: np.ndarray, player_pos: tuple, radius: int = 3):
    """
    Generates the agent's vision based on the field and player position.
    Parameters:
    - self: The instance of the class.
    - field (numpy.ndarray): The game field.
    - player_pos (tuple): The player position.
    Returns:
    - vision (numpy.ndarray): The agent's vision.
    The function generates the agent's vision by creating a 3x3 grid centered around the player position.
    The function returns the agent's vision.
    """
    vision = np.zeros((2*radius+1, 2*radius+1))    

    left = player_pos[0] - radius
    left = 0 if left < 0 else left
    right = player_pos[0] + radius
    right = field.shape[0] if right >= field.shape[0] else right 
    up = player_pos[1] - radius
    up = 0 if up < 0 else up
    down = player_pos[1] + radius
    down = field.shape[1] if down >= field.shape[1] else down

    for i in range(left, right):
        for j in range(up, down):
            vision[i-left, j-up] = field[i, j]

    return vision


def calculate_dist_to_obj(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 2  # Wall (not passable)
    grid[field == -2] = 80  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 100
    grid[field == 3] = 85
    grid[field == 4] = 90
    grid[field == 5] = 95
    grid[field == 1] = 0
    grid[field == 2] = 0
    
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 2)
    for wall in walls:
        graph.remove_node(tuple(wall))


    # Find the start node
    start = tuple(player_pos)

    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
 
def dijkstra(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 0 # Wall (not passable)
    grid[field == -2] = 1  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 1
    grid[field == 1] = 1
    grid[field == 2] = 1
    grid[field == 3] = 1
    grid[field == 4] = 1
    grid[field == -3] = 1
    
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 0)
    for wall in walls:
        graph.remove_node(tuple(wall))


    # Find the start node
    start = tuple(player_pos)

    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
