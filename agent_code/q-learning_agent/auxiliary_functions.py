import numpy as np
import networkx as nx

def set_objetive(self, game_state: dict):
    """
    TO BE MADE BETTER SO THAT IT CHOOSES THE NEAREST OBJECTIVE.
    S
    Sets the objective for the agent based on the game state.
    Parameters:
    - game_state (dict): The current game state containing the field and coin information.
    Returns:
    - objective: The objective for the agent, which can be a crate or a coin.
    """
    field = game_state['field']
    coin_array=game_state['coins']
    player_pos = game_state['self'][3]

    if not coin_array:
        crates = np.argwhere(field == -2) #probar que esto nos da correctamente los crates o solamente una e las coordenadas.
        if not np.any(crates):
            objective = player_pos
        else:
            objective = crates[0]
        #to be refined in this way in the future. Now we will always have a crate or a coin.

        #no coins in the field. Set new objetcive to the nearest crate.
        #crates = np.argwhere(field == 1)
        #if not crates:
            #no crates in the field. Set new objetcive to the nearest opponent.

            #NEW OBJETCTIVE NOT REALLY SET. IT SHOULD BE TO KILL NEAREST OPPONENT!
        #    other_agents = game_state['others']
        #else:
        #    nearest_crate = crates[0]
    else:
        objective = coin_array[0]
    
    return tuple(objective)


def bomb_map(self, game_state: dict)->np.ndarray:
    
    """
    Generates a bomb map based on the given game state, and that behind a wall the agent is protected from the bomb.
    Parameters:
    - game_state (dict): The current game state containing the field and bomb information.
    Returns:
    - bomb_map: A 2D array representing the bomb map, where each element represents the timer value of a bomb.
    The bomb map is generated by iterating over the bombs in the game state and updating the timer values of the affected tiles.
    The size of the bomb map is adjusted to match the size of the field in the game state.
    The initial timer value for each tile is set to 5, and explodes when it reaches 1.
    The timer value of a tile is updated if a bomb with a shorter timer is found.
    The bomb map is returned as a 2D array.
    """
    field = game_state['field']

    #adjust size of the bomb map to the field size
    bomb_map = np.full((7,7), 6)
    bombs = game_state['bombs']
    if bombs:
        for bomb in game_state['bombs']:
            bomb_center_x, bomb_center_y = bomb[0][0], bomb[0][1]
            #print(bomb[0])
            bomb_timer = bomb[1] + 1
            #affected tiles classic scenario
            #affected_tiles_up = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
            #affected_tiles_down = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
            #affected_tiles_left = [(bomb_center_x-1, bomb_center_y), (bomb_center_x-2, bomb_center_y), (bomb_center_x-3, bomb_center_y)]
            #affected_tiles_right = [(bomb_center_x+1, bomb_center_y), (bomb_center_x+2, bomb_center_y), (bomb_center_x+3, bomb_center_y)]
            
            #affected tiles 1-goal scenario
            #We consider in affected_tiles_up the bomb center and in the rest not.
            affected_tiles_up = [(bomb_center_x, bomb_center_y),(bomb_center_x, bomb_center_y-1)]
            affected_tiles_down = [(bomb_center_x, bomb_center_y+1)]
            affected_tiles_left = [(bomb_center_x-1, bomb_center_y)]
            affected_tiles_right = [(bomb_center_x+1, bomb_center_y)]

            for tile in affected_tiles_up:
                if field[tile] == -1:
                    break
                timer_tile = bomb_map[tile] 
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_down:
                if field[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_left:
                if field[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_right:
                if field[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile
    else:
        bomb_map = np.full((7,7), 0)

    return bomb_map

def build_field(self, game_state: dict):
    """
    Builds the game field based on the given game state.
    Parameters:
    - self: The instance of the class.
    - game_state (dict): The dictionary containing the game state.
    Returns:
    - field (numpy.ndarray): The built game field.
    The function builds the game field by adjusting the scale of crates to -2, coins to -3, 
    and adjusting the field to show the countdown to explosions [4,3,2,1] and 1 for explosion,
    and 0 being free space.
    The function returns the built game field.
    """
    field = game_state['field']
    bombmap = bomb_map(self, game_state)
    explosion_map = game_state['explosion_map']
    
    # adjust scale of crates to -2
    field[field == 1] = -2 

    # explosions are present two steps. explosion map shows the second step of the explosion.
    field[explosion_map == 1] = 1

    # adjust field to show countdown to explosions (1 being just exploded)
    cond = ((bombmap == 4) | (bombmap == 3) | (bombmap == 2) | (bombmap == 1))
    field[cond] = bombmap[cond]

    objective = set_objetive(self, game_state)
    if (objective in game_state['coins']) and (field[objective] != 0,1,2,3,4):
        field[objective] = -3
    return field


    

def calculate_dist_to_obj(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 2  # Wall (not passable)
    grid[field == -2] = 80  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 100
    grid[field == 3] = 85
    grid[field == 4] = 90
    grid[field == 5] = 95
    grid[field == 1] = 0
    grid[field == 2] = 0
    
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 2)
    for wall in walls:
        graph.remove_node(tuple(wall))


    # Find the start node
    start = tuple(player_pos)

    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
 
def dijkstra(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 0 # Wall (not passable)
    grid[field == -2] = 1  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 1
    grid[field == 1] = 1
    grid[field == 2] = 1
    grid[field == 3] = 1
    grid[field == 4] = 1
    grid[field == -3] = 1
    
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 0)
    for wall in walls:
        graph.remove_node(tuple(wall))


    # Find the start node
    start = tuple(player_pos)

    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
