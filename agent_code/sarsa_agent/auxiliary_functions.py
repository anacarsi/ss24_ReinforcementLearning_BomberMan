import numpy as np
import networkx as nx

def set_objetive(self, game_state: dict):
    """
    TO BE MADE BETTER SO THAT IT CHOOSES THE NEAREST OBJECTIVE.
    S
    Sets the objective for the agent based on the game state.
    Parameters:
    - game_state (dict): The current game state containing the field and coin information.
    Returns:
    - objective: The objective for the agent, which can be a crate or a coin.
    """
    field = game_state['field']
    coin_array=game_state['coins']
    player_pos = game_state['self'][3]

    if not coin_array:
        crates = np.argwhere(field == -2) #probar que esto nos da correctamente los crates o solamente una e las coordenadas.
        if not np.any(crates):
            objective = player_pos
        else:
            objective = crates[0]
        #to be refined in this way in the future. Now we will always have a crate or a coin.

        #no coins in the field. Set new objetcive to the nearest crate.
        #crates = np.argwhere(field == 1)
        #if not crates:
            #no crates in the field. Set new objetcive to the nearest opponent.

            #NEW OBJETCTIVE NOT REALLY SET. IT SHOULD BE TO KILL NEAREST OPPONENT!
        #    other_agents = game_state['others']
        #else:
        #    nearest_crate = crates[0]
    else:
        objective = coin_array[0]
    

    return tuple(objective)


def bomb_map(self, game_state: dict)->np.ndarray:
    
    """
    Generates a bomb map based on the given game state, and that behind a wall the agent is protected from the bomb.
    Parameters:
    - game_state (dict): The current game state containing the field and bomb information.
    Returns:
    - bomb_map: A 2D array representing the bomb map, where each element represents the timer value of a bomb.
    The bomb map is generated by iterating over the bombs in the game state and updating the timer values of the affected tiles.
    The size of the bomb map is adjusted to match the size of the field in the game state.
    The initial timer value for each tile is set to 5, and explodes when it reaches 1.
    The timer value of a tile is updated if a bomb with a shorter timer is found.
    The bomb map is returned as a 2D array.
    """
    field = game_state['field']

    #adjust size of the bomb map to the field size
    bomb_map = np.full((7,7), 6)
    bombs = game_state['bombs']
    if bombs:
        for bomb in game_state['bombs']:
            bomb_center_x, bomb_center_y = bomb[0][0], bomb[0][1]
            bomb_timer = bomb[1]+1
            #affected tiles classic scenario
            #affected_tiles_up = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
            #affected_tiles_down = [(bomb_center_x, bomb_center_y-1), (bomb_center_x, bomb_center_y-2), (bomb_center_x, bomb_center_y-3)]
            #affected_tiles_left = [(bomb_center_x-1, bomb_center_y), (bomb_center_x-2, bomb_center_y), (bomb_center_x-3, bomb_center_y)]
            #affected_tiles_right = [(bomb_center_x+1, bomb_center_y), (bomb_center_x+2, bomb_center_y), (bomb_center_x+3, bomb_center_y)]
            
            #affected tiles 1-goal scenario
            affected_tiles_up = [(bomb_center_x, bomb_center_y-1)]
            affected_tiles_down = [(bomb_center_x, bomb_center_y+1)]
            affected_tiles_left = [(bomb_center_x-1, bomb_center_y)]
            affected_tiles_right = [(bomb_center_x+1, bomb_center_y)]

            for tile in affected_tiles_up:
                if bomb_map[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_down:
                if bomb_map[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_left:
                if bomb_map[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile

            for tile in affected_tiles_right:
                if bomb_map[tile] == -1:
                    break
                timer_tile = bomb_map[tile]
                bomb_map[tile] = bomb_timer if (timer_tile > bomb_timer) else timer_tile
    else:
        bomb_map = np.full((7,7), 0)

    return bomb_map

def calculate_dist_to_obj(player_pos, objective_pos, field):
    """
    Calculates the path to the objective using Dijkstra's algorithm.
    Returns the path to the coin.
    """
    # Create a grid of ones and zeros
    # 0 represents a wall, 1 represents a free space
    grid = np.zeros(field.shape)
    grid[field == -1] = 2  # Wall (not passable)
    grid[field == -2] = 80  # Crate (not passable)
    #to afjust when we change size of the field
    grid[field == 0] = 100
    grid[field == 3] = 85
    grid[field == 4] = 90
    grid[field == 5] = 95
    grid[field == 1] = 0
    grid[field == 2] = 0


    
    
    # Create a graph from the grid
    graph = nx.grid_2d_graph(grid.shape[0], grid.shape[1])
    
    # Remove nodes that represent walls
    walls = np.argwhere(grid == 2)
    for wall in walls:
        graph.remove_node(tuple(wall))


    # Find the start node
    start = tuple(player_pos)

    # Find the path to the coin
    try:
        path = nx.shortest_path(graph, start, tuple(objective_pos), method='dijkstra')
    except nx.NetworkXNoPath:
        # No path found to this coin
        path = []

    return path
